% !TEX encoding = UTF-8 Unicode
%!TEX root = ../Main/thesis.tex
% !TEX spellcheck = en-US
%%=========================================
\documentclass[../Main/thesis.tex]{subfiles}
\begin{document}
\chapter{Theory}
\label{ch:theory}
In this section we will take a closer look at the theory surrounding
supply chains, reproducible builds, transparency logs and rebuilders.

\section{Supply Chains}\label{sec:supply_chain}
\subsection*{The Supply Chain}
%  \say{Traditionally, supply chains have also been linked to the movement of
%  raw materials and subcomponents through a manufacturing process for
%  consumer products such as automobiles and appliances.}

Most of the software today are developed through a series of steps. This is
traditionally called ``The Software Supply Chain'' and encompasses the
development of the software, all the way to the delivery of the project to the
end-user \cite{rj-ellison-2010}.

Software projects today go through development, building, testing, staging and
in the end production, with slight variations between 

In the world of open-source the software delivery are usually done by Linux
distributions, or other similar methods of distributions. The supply chain in
this regard is the complete steps from developers getting the source code for
the project, until it is delivered as a compiled artifact to the end-user. This
also includes the wider network of packages that are needed for the distribution
of the project. This is broader then looking at it as a ``software delivery
lifecycle'' which only encompasses the release of the project.

In this thesis we will focus on how package managers work as a supply chain for
the Linux distribution Debian.

% TODO: Software Delivery Lifecycle

\subsubsection*{in-toto}
in-toto is a framework to verify the integrity of a supply chain. It defines a
specification that details what steps should occur. As one supply chain could
define and utilize any number of steps its vital for this to be extensible, and
customize able. In-toto lets the specification detail who should perform the
step in the supply chain.

The layout describes what each step of the supply chain should contain. It can
be any expected commands, something the process should succeed running, any
expected material, things needed for the step in the chain to proceed, and any
products, artifacts created by the steps. These are described in a very shallow
and each language that contains keywords following regular expressions which
should be satisfied.

These steps can be be ``inspected'' to verify ...

The link metadata is a JSON file that specifies what the values, and outputs of
the corresponding step should be. Evaluating the specification along with the
link metadata lets the users, or the organization, verify that the supply chain
has not been tampered with. 

\begin{minted}[]{json}
{"signatures": [],
 "signed": {
  "_type": "layout",
  "expires": "2021-01-06T18:30:57Z",
  "inspect": [{
        "_type": "inspection",
        "expected_materials": [
             ["MATCH", "*.deb", "WITH", "PRODUCTS", "FROM", "rebuild"],
             ["DISALLOW", "*.deb"]],
        "expected_products": [],
        "name": "verify-reprobuilds",
        "run": ["/usr/bin/true"]}],
  "keys": {
        "2e7be98291270e3b7fca429a2210e99cff22017e":{
             "hashes": ["pgp+SHA2"],
             "keyid": "2e7be98291270e3b7fca429a2210e99cff22017e",
             "keyval": {"private": "", "public": {"e": "010001", "n": "e0da84bec..."}},
             "method": "pgp+rsa-pkcsv1.5",
             "type": "rsa"}},
  "readme": "",
  "steps": [{
        "_type": "step",
        "expected_products": [
             ["CREATE", "*.deb"],
             ["DISALLOW", "*.deb"]],
        "name": "rebuild",
        "pubkeys": ["2e7be98291270e3b7fca429a2210e99cff22017e"],
        "threshold": 1}]
}}
\end{minted}

\begin{minted}[]{json}
{"signatures": [
  {"keyid": "918b19596...",
   "other_headers": "0400010800...",
   "signature": "bc1d9776bf..."}],
 "signed": {
  "_type": "link",
  "name": "rebuild",
  "products": {
   "python-sshpubkeys_3.1.0-1_all.deb": {"sha256": "8e69d5cbdc..."},
   "python3-sshpubkeys_3.1.0-1_all.deb": {"sha256": "8234484139..."}}
}}
\end{minted}


\section{Linux Distributions}\label{sec:linux_distributions}
\subsection*{Linux}
Linux is free and open-source kernel. It was first developed by Linus Torvalds
in the early 1990 and has grown into the largest open-source project today. It
is commonly used in everything from firmware modules on a computer, to the every
increasing field of Internet of Thing, along with servers and on personal
computers.

Linux is accompanied by a suit of tools and environment that is commonly
referred to as a ``distribution'' and defines an operating system based on
Linux. These are created by companies as commercial products, as well as groups
of volunteers as a hobby for free. A lot of open-source development is done
with, and for, Linux.

\subsection*{Debian}
Debian was one of the first operating systems based on Linux, and was created by
Ian Murdock in 1993. One of the main innovations from debian was the creation of
the very first package manager. Package manager allows users to download
pre-compiled software from centralized repositories maintained by the Debian
developers. This allows users to easily fetch, update and remove installed
packages on their system.

These packages are maintained by package maintainers who package, update and
maintain the required files to distribute this to the end user. Each maintainer
has a cryptographic secure singing key they use to fetch, and publish source
packages to a build server. These source packages contains the needed files,
patches and package files to compile the project source code to a format
accepted by the debian package manager, apt.

The build server verifies the signatures and compile these source packages to
the all the supported architectures. It will then sign these packages with its
own key, and then distribute these to the end-user in the form of a mirror
system.


\section{Software determinism}\label{sec:reproducible_builds}
% TODO: Usikker på struktur.
% Skal seksjonen hete reproducible builds? 

\subsection*{Trusting trust}
In a paper from Ken Thompson in 1984, after he won the Turing Award for his work
on the UNIX operating system, \citetitle{ken-thompson-1984}, Thompson as a
programming exercise implements a very basic self-reproducing program. As a
demonstration, he adds code capable of introducing new code when certain
patterns are encountered. This implements a backdoor in something that could

\begin{quotation}
``You can't trust code that you did not totally create yourself. [...] No amount
of source-level verification or scrutiny will protect you from using untrusted
code. In demonstrating the possibility of this kind of attack, I picked on the C
compiler. I could have picked on any program-handling program such as an
assembler, a loader, or even hardware microcode. As the level of program gets
lower, these bugs will be harder and harder to detect.  A well-installed
microcode bug will be almost impossible to detect''\cite{ken-thompson-1984}.
\end{quotation}

% TODO: Research into software verifiability
This paints a very bleak picture, considering most software we get today is
pre-compiled and provided to us by different vendors.

% TODO: Move into diverse compilation. Reprobuilds an extension

But there are possible ways to counter this problem.  David A. Wheeler in his
dissertation \citetitle{david-a.-wheeler-2009} from 2009 details a possible
solution to the ``trusting trust''-problem. It involves what he call diverse
``diverse compilation'' where the source is compiled with one trusted compiler,
and any subsequent compilers to detect any flaws or malicious code.

It has some caveat; 


Reproducible builds is in many ways a different take on the same problem.

\subsection*{Reproducible builds}
Reproducible builds is a set of practices for how to achieve deterministic
compilation of software. Supply chains are usually handled with multiple tools,
and on several individual computers, this leaves a rather large attack surface
for malicious actors to try compromise the chain. This is not a theoretical
threat. There has been an increase in attacks on parts of supply chains in
recent years. They are high impact and affect users as well as developers.

According to the definition of reproducible build;

\begin{quotation}
``A build is reproducible if given the same source code, build environment
and build instructions, any party can recreate bit-by-bit identical copies of
all specified artifacts'' \cite{reproducible-builds-2019-definitions}.
\end{quotation}


% TODO: Bitcoin
% TODO: Tor project

\subsection*{Source Date Epoch}
One of the most common offenders for undeterministic builds is the embedding of
when something was built. On the surface this looks like a completely sane thing
to do for most builds, but this creates problems when the produced artifact in
turns become undeterministic because we built it at another point in time.

The reproducible builds project defines an environment variable called
``SOURCE\_DATE\_EPOCH'' which is an means to solve this dilemma
\cite{reproducible-builds-2019-source-date-epoch}. The variable enables software
distributors to build artifacts with an embedded time, but it also helps to
specify the time in a manner that enables reproducible builds as we can set the
date arbitrarily.

% TODO: Skrive mer
The requirement is that this variable is exported in the build system used to
create the package. 

\subsection*{Buildinfo}
% TODO: Kanskje nevne økosystemer bedre?
One of the main issues with reproducible builds is that is hard to make
everything universally reproducible. Producing the same binary package on
multiple different linux distributions is close to impossible and unmanageable
for most software. Thus we need to specify the environment being utilized with
all of the requirements and idiosyncrasies.

This is not a new discovery.
\citeauthor{r.-torres-cabrera-and-bonnie-lee-appleton-1999} in their paper
\citetitle{r.-torres-cabrera-and-bonnie-lee-appleton-1999} from 1999, they
defined a ``Bill of Material'', or a ``BOM'' for short.

\begin{quotation}
``Document all of the components that contributed to the build in a list, i.e.,
a bill of materials (BOM). The BOM may contain the names, versions, and
directory paths of operating systems, libraries, compilers, linkers, make-files,
build scripts, etc The BOM may be manually created, but many configuration
management tools generate it as a by- product of the build'' \cite{r.-torres-cabrera-and-bonnie-lee-appleton-1999}.
\end{quotation}

Such a file would contain all the requirements to recreate the environment the
artifact was built inn. Because of the previously mentioned restrictions, one
there needs to exist multiple formats to define the requirements. Currently
there are around 5 different formats for different ecosystems on the
reproducible builds website \cite{reproducible-builds-2019}.

% TODO: Legg til source på deb-buildinfo

The debian format encompasses a wide array of values ``Format'' defines
the expected fields in the format and gets incremented with any changes.
``Source'' and ``Binary'' defines the source package used to produce this, and
the corresponding binary package it outputs. The ``Architecture'' fields defines
which architecture the product is compiled towards. Debian supports a wide array
of CPU architectures from ARM to AMD 64 bit. High-level languages usually does
not compile, there for ``all'' is used to denote this.

The ``Build-'' variables denotes the build environment used to create the
artifact in the debian ecosystem. Since debian has a slew of derivative and
closely related distributions, ``Build-Origin'' is used to denote this
distribution.  ``Build-Architecture'' denotes the architecture of the build
server being used.  ``Build-Kernel-Version'' denotes the explicit  version of
the kernel used. This is commonly fetched with the command ``uname -a''.
``Build-Date'' refers to the ISO compatible date when the process took place.
``Build-Path'' is the location where the build took place.
``Installed-Build-Depends'' contains list of all packages present during the
packaging of this artefact. This s an important list to keep track of as it
enables the complete recreation of the environment at a later point.

Linux has several variables that sets the locale, language and timestamp format,
that can affect the build process. ``Environment'' encompasses all of these.
Most importantly the variable ``SOURCE\_DATE\_EPOCH'' is stored here to make sure
timestamps are deterministic.

\begin{minted}[]{text}
Format: 1.0
Source: dh-make
Binary: dh-make
Architecture: all
Version: 2.201802
Checksums-Sha256:
22c95094efbe79445336007dd[...] 42360 dh-make_2.201802_all.deb
Build-Origin: Debian
Build-Architecture: amd64
Build-Kernel-Version: 4.9.0-8-amd64 #1 SMP Debian 4.9.110-3 (2018-10-08)
Build-Date: Thu, 06 Dec 2018 00:04:23 +0000
Build-Path: /build/dh-make-2.201802
Installed-Build-Depends:
autoconf (= 2.69-11),
automake (= 1:1.16.1-4),
[...]
xz-utils (= 5.2.2-1.3),
zlib1g (= 1:1.2.11.dfsg-1)
Environment:
DEB_BUILD_OPTIONS="buildinfo=+all reproducible=+all parallel=16"
LANG="C"
LC_ALL="POSIX"
SOURCE_DATE_EPOCH="1543231660"
\end{minted}

\section{Rebuilders}\label{sec:rebuilders} 
One of the main ideals with reproducible builds is the ability to let the users
recreate distributed artifacts. This is achievable with the correct tooling, and
a ``BUILDINFO'' file as specified in the previous section. However,building all
distributed packages is an unwieldy task. The appeal of linux distributions is
the ability to download pre-compiled packages to save the effort of building all
the software one intend to use.

One of the ideas from the 204 reproducible builds summit is to provide
infrastructure that rebuilds the packages distributed by the linux distribution.


% TODO: Attestation sharing source
% TODO: Source - planned in 2014/2-16 by the project

\section{Merkle Trees}
Merkle Trees is a tree structure based on cryptographic secure hashing function
\cite{ralph-c.-merkle-1998}. It creates a binary tree where each leaf is hashed,
and combined two and two. The top node of this tree is reffed to as a ''root
node''. The interesting property of merkle trees is the ability to verify the
inclusion of elements by calculating the path from the given leaf to the root
node. This can be done by acquiring the missing hashes for each intermediate
node, and then hash each of the steps together.

% \subsection*{Blockchain}

\subsubsection*{Certificate transparency log}
Certificate transparency logs uses merkle trees to give organization issuing
TLS certificates, as used in HTTP, a log of who and what issues
log.\cite{b.-laurie-a.-langley-e.kaster-google-2013} This is used to detect
cases where certificate issue keys have been compromised, or if certificates
have been issued for domains as a form of misuse.

Proofs in the context of transparency logs are tuple pairs where the first
element describes the position, and the second element includes the hash of
the given object. Given the correct order of hashing, the product of this
should be some merkle tree root the log is either currently using, or have
used in the past.

There are three features needed to implement a transparency log.

\begin{itemize}
\item Audit proof
\item Inclusion proof
\item Consistency proof
\end{itemize}

Each of this proofs are needed to correctly verify that a transparency log
is correctly operating and can verify this to monitors.  Monitors follow
these logs to assure consistency and to make sure logs do not misbehave. It
also allows monitors to verify the append-only property of the log.

The audit proof is used to  verify that the given element in the log exists
in the log. The tree root is given, along with the elements needed to
recreate the missing nodes for the root.

The consistency proof is used to verify that the log is operating as an
append-only log in a correct manner. This proof requires two things. A
previous merkle tree root, and the number of leafs present at the time of
this tree root. The returned path is the number of subroots needed to
recreate the path from the root, until the new root.

\section{Development}\label{sec:development} 
In this section we will take a look at the language and libraries used to
develop this project.

\subsection*{Python}
Python is a general purpose programming language created by Gudio van Rossum in
1994. It's dynamically typed language, with a terse syntax and a wide selection
of built-in libraries for developers. It's well suited for prototyping
technologies and has several well developed libraries.

\subsection*{flask}
Flask is a web framework for Python. It was created in 2010 by Armin Ronacher,
and is one of the two most widely popular web frameworks in python. It enabled
developers to easily create REST APIs with good debugging capabilities.

\subsection*{postgresql}
postgresql is a open-source relational database. It supports a wide number of
abstract datatypes, such as native support for JSON, along with good support for
concurrent operation. This enables easier development, along higher workloads
and scalability.

\subsection*{sqlalchemy}
sqlalchemy is a widely used object relation mapping library for python. It
support a wide selection of database backends and translates the raw database
data into usable python objects for easier interopability.

\subsection*{Panda and matplotlib}
For graphing we will be using pandas and matplotlib. Both used a lot when it
comes to scientific computing with python. It enables powerful graphing
capabilities over simply dataformats, such as CSV, and are tightly integrated
into one another.

\section*{Summary}\label{sec:summary-theory} 
In this chapter we have taken a deeper look at the theory surrounding supply
chains, reproducible builds and merkle trees. In the next chapter we will be
taking a look at the current research being done towards shared attestation on
reproducible builds and package transparency logs.

\blankpage
\end{document}
