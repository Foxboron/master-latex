% !TEX encoding = UTF-8 Unicode
%!TEX root = ../Main/thesis.tex
% !TEX spellcheck = en-US
%%=========================================
\documentclass[../Main/thesis.tex]{subfiles}
\begin{document}
\chapter{Theory}
\label{ch:theory}
In this section we will take a closer look at the theory surrounding
supply chains, reproducible builds, transparency logs and rebuilders.

\section{Supply Chains}\label{sec:supply_chain}
    \subsection*{The Supply Chain}
   %  \say{Traditionally, supply chains have also been linked to the movement of
   %  raw materials and subcomponents through a manufacturing process for
   %  consumer products such as automobiles and appliances.}

    Most of the software today are developed through a series of steps. This is
    traditionally called ``The Software Supply Chain'' and encompasses the
    development of the software, all the way to the delivery of the project
    to the end-user \cite{rj-ellison-2010}.

    Software projects today go through development, building, testing, staging
    and in the end production, with slight variations between 

    In the world of open-source the software delivery are usually done by Linux
    distributions, or other similar methods of distributions. The supply chain
    in this regard is the complete steps from developers getting the source code
    for the project, until it is delivered as a compiled artifact to the
    end-user. This also includes the wider network of packages that are needed
    for the distribution of the project. This is broader then looking at it as a
    ``software delivery lifecycle'' which only encompasses the release of the
    project.

    In this thesis we will focus on how package managers work as a supply chain
    for the Linux distribution Debian.

    % TODO: Software Delivery Lifecycle

    \subsubsection*{in-toto}
    in-toto is a framework to verify the integrity of a supply chain. It defines
    a specification that details what steps should occur. As one supply chain
    could define and utilize any number of steps its vital for this to be
    extensible, and customize able. In-toto lets the specification detail who
    should perform the step in the supply chain.
  
    The layout describes what each step of the supply chain should contain. It
    can be any expected commands, something the process should succeed running,
    any expected material, things needed for the step in the chain to proceed,
    and any products, artifacts created by the steps. These are described in a
    very shallow and each language that contains keywords following regular
    expressions which should be satisfied.

    These steps can be be ``inspected'' to verify 

    The link metadata is a JSON file that specifies what the values, and outputs
    of the corresponding step should be. Evaluating the specification along with
    the link metadata lets the users, or the organization, verify that the
    supply chain has not been tampered with. 

\begin{minted}[]{json}
{"signatures": [],
 "signed": {
  "_type": "layout",
  "expires": "2021-01-06T18:30:57Z",
  "inspect": [{
        "_type": "inspection",
        "expected_materials": [
             ["MATCH", "*.deb", "WITH", "PRODUCTS", "FROM", "rebuild"],
             ["DISALLOW", "*.deb"]],
        "expected_products": [],
        "name": "verify-reprobuilds",
        "run": ["/usr/bin/true"]}],
  "keys": {
        "2e7be98291270e3b7fca429a2210e99cff22017e":{
             "hashes": ["pgp+SHA2"],
             "keyid": "2e7be98291270e3b7fca429a2210e99cff22017e",
             "keyval": {"private": "", "public": {"e": "010001", "n": "e0da84bec..."}},
             "method": "pgp+rsa-pkcsv1.5",
             "type": "rsa"}},
  "readme": "",
  "steps": [{
        "_type": "step",
        "expected_command": [],
        "expected_materials": [],
        "expected_products": [
             ["CREATE", "*.deb"],
             ["DISALLOW", "*.deb"]],
        "name": "rebuild",
        "pubkeys": ["2e7be98291270e3b7fca429a2210e99cff22017e"],
        "threshold": 1
}]}}
\end{minted}

\begin{minted}[]{json}
{"signatures": [
  {"keyid": "918b19596...",
   "other_headers": "0400010800...",
   "signature": "bc1d9776bf..."
  }],
 "signed": {
  "_type": "link",
  "byproducts": {},
  "command": [],
  "environment": {},
  "materials": {},
  "name": "rebuild",
  "products": {
   "python-sshpubkeys_3.1.0-1_all.deb": {
    "sha256": "8e69d5cbdc6eb2c90a522bbca949b4f3565f5d55c4c01542a710c8df4ae2e34d"
   },
   "python3-sshpubkeys_3.1.0-1_all.deb": {
    "sha256": "8234484139230459733466ef7e64176f109718ea3fbec7da5c124d7508c4f914"
   }
  }
 }
}
\end{minted}


\section{Linux Distributions}\label{sec:linux_distributions}
    \subsection*{Linux}
    Linux is free and open-source kernel. It was first developed by Linus
    Torvalds in the early 1990 and has grown into the largest open-source
    project today. It is commonly used in everything from firmware modules on a
    computer, to the every increasing field of Internet of Thing, along with
    servers and on personal computers.

    Linux is accompanied by a suit of tools and environment that is commonly
    referred to as a ``distribution'' and defines an operating system based on
    Linux. These are created by companies as commercial products, as well as
    groups of volunteers as a hobby for free. A lot of open-source development
    is done with, and for, Linux.

    \subsection*{Debian}
    Debian was one of the first operating systems based on Linux, and was
    created by Ian Murdock in 1993. One of the main innovations from debian was
    the creation of the very first package manager. Package manager allows users
    to download pre-compiled software from centralized repositories maintained
    by the Debian developers.  This allows users to easily fetch, update and
    remove installed packages on their system.

    These packages are maintained by package maintainers who package, update and
    maintain the required files to distribute this to the end user. Each
    maintainer has a cryptographic secure singing key they use to fetch, and
    publish source packages to a build server. These source packages contains
    the needed files, patches and package files to compile the project source
    code to a format accepted by the debian package manager, apt.

    The build server verifies the signatures and compile these source packages
    to the all the supported architectures. It will then sign these packages
    with its own key, and then distribute these to the end-user in the form of a
    mirror system.


\section{Reproducible Builds}\label{sec:reproducible_builds}

    Reproducible builds is a set of practices for how to achieve deterministic
    compilation of software. Supply chains are usually handled with multiple
    tools, and on several individual computers, this leaves a rather large
    attack surface for malicious actors to try compromise the chain. This is not
    a theoretical threat. There has been an increase in attacks on parts of
    supply chains in recent years. They are high impact and affect users as well
    as developers.

    According to the definition of reproducible build;

    \say{A build is reproducible if given the same source code, build
    environment and build instructions, any party can recreate bit-by-bit
identical copies of all specified
artifacts}\cite{reproducible-builds-2019-definitions}

    % TODO: Reproducible builds definition source

    \subsection*{Software Determinism}

    % TODO: Thompson trusting trust
    % TODO: 1991 - reproducible builds

    \subsection*{Source Date Epoch}
    
    % TODO: SOURCE_DATE_EPOCH source

    \subsection*{Buildinfo}
    To record build time values, such as ``SOURCE\_DATE\_EPOCH'', the
    reproducible builds project has identified a need to record the build
    environment used to create artifacts.
  
    % TODO: Forklare de forskjellige tingene som blir skrevet ned.
    
    This format is mostly unique for each ecosystem as the available tools have
    different parsers available. Currently there JVM, Arch Linux and Debian
    record this using different formats \cite{reproducible-builds-2019}.

    \begin{minted}[]{text}
Format: 1.0
Source: dh-make
Binary: dh-make
Architecture: all
Version: 2.201802
Checksums-Sha256:
22c95094efbe79445336007dd[...] 42360 dh-make_2.201802_all.deb
Build-Origin: Debian
Build-Architecture: amd64
Build-Kernel-Version: 4.9.0-8-amd64 #1 SMP Debian 4.9.110-3 (2018-10-08)
Build-Date: Thu, 06 Dec 2018 00:04:23 +0000
Build-Path: /build/dh-make-2.201802
Installed-Build-Depends:
autoconf (= 2.69-11),
automake (= 1:1.16.1-4),
[...]
xz-utils (= 5.2.2-1.3),
zlib1g (= 1:1.2.11.dfsg-1)
Environment:
DEB_BUILD_OPTIONS="buildinfo=+all reproducible=+all parallel=16"
LANG="C"
LC_ALL="POSIX"
SOURCE_DATE_EPOCH="1543231660"
    \end{minted}

    \subsection*{Rebuilders}%\label{sec:rebuilders} 

    % TODO: Attestation sharing source
    % TODO: Source - planned in 2014/2-16 by the project

\section{Merkle Trees}
Merkle Trees is a tree structure based on cryptographic secure hashing function
\cite{ralph-c.-merkle-1998}. It creates a binary tree where each leaf is hashed,
and combined two and two. The top node of this tree is reffed to as a ''root
node''. The interesting property of merkle trees is the ability to verify the
inclusion of elements by calculating the path from the given leaf to the root
node. This can be done by acquiring the missing hashes for each intermediate
node, and then hash each of the steps together.

    % \subsection*{Blockchain}

    \subsubsection*{Certificate transparency log}
    Certificate transparency logs uses merkle trees to give organization issuing
    TLS certificates, as used in HTTP, a log of who and what issues
    log.\cite{b.-laurie-a.-langley-e.kaster-google-2013} This is used to detect
    cases where certificate issue keys have been compromised, or if certificates
    have been issued for domains as a form of misuse.

    Proofs in the context of transparency logs are tuple pairs where the first
    element describes the position, and the second element includes the hash of
    the given object. Given the correct order of hashing, the product of this
    should be some merkle tree root the log is either currently using, or have
    used in the past.

    There are three features needed to implement a transparency log.

    \begin{itemize}
        \item Audit proof
        \item Inclusion proof
        \item Consistency proof
    \end{itemize}

    Each of this proofs are needed to correctly verify that a transparency log
    is correctly operating and can verify this to monitors.  Monitors follow
    these logs to assure consistency and to make sure logs do not misbehave. It
    also allows monitors to verify the append-only property of the log.

   The audit proof is used to  verify that the given element in the log exists
   in the log. The tree root is given, along with the elements needed to
   recreate the missing nodes for the root.

   The consistency proof is used to verify that the log is operating as an
   append-only log in a correct manner. This proof requires two things. A
   previous merkle tree root, and the number of leafs present at the time of
   this tree root. The returned path is the number of subroots needed to
   recreate the path from the root, until the new root.



\section{Development}\label{sec:development} 
In this section we will take a look at the language and libraries used to
develop this project.

    \subsection*{Python}
    Python is a general purpose programming language created by Gudio van Rossum
    in 1994. It's dynamically typed language, with a terse syntax and a wide
    selection of built-in libraries for developers. It's well suited for
    prototyping technologies and has several well developed libraries.

    \subsection*{flask}
    Flask is a web framework for Python. It was created in 2010 by Armin
    Ronacher, and is one of the two most widely popular web frameworks in
    python. It enabled developers to easily create REST APIs with good debugging
    capabilities.

    \subsection*{postgresql}
    postgresql is a open-source relational database. It supports a wide number
    of abstract datatypes, such as native support for JSON, along with good
    support for concurrent operation. This enables easier development, along
    higher workloads and scalability.

    \subsection*{sqlalchemy}
    sqlalchemy is a widely used object relation mapping library for python. It
    support a wide selection of database backends and translates the raw
    database data into usable python objects for easier interopability.

    \subsection*{Panda and matplotlib}
    For graphing we will be using pandas and matplotlib. Both used a lot when it
    comes to scientific computing with python. It enables powerful graphing
    capabilities over simply dataformats, such as CSV, and are tightly
    integrated into one another.

\section*{Summary}\label{sec:summary-theory} 
In this chapter we have taken a deeper look at the theory surrounding supply
chains, reproducible builds and merkle trees. In the next chapter we will be
taking a look at the current research being done towards shared attestation on
reproducible builds and package transparency logs.

\blankpage
\end{document}
